package main

import (
	"bytes"
	"fmt"
	"go/format"
	"go/token"
	"os/exec"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/davecgh/go-spew/spew"
	log "github.com/sirupsen/logrus"
)

var (
	generatedTerms = []string{
		"do not edit",
		"generated by",
	}
	goDirectiveLine = regexp.MustCompile(`\s*//\s*go:.*`)
)

const maxRounds = 20

type Shortener struct {
	maxLen            int
	tabLen            int
	keepAnnotations   bool
	shortenComments   bool
	ignoreGenerated   bool
	baseFormatter     string
	baseFormatterArgs []string
}

func NewShortener(
	maxLen int,
	tabLen int,
	keepAnnotations bool,
	shortenComments bool,
	ignoreGenerated bool,
	baseFormatter string,
) *Shortener {
	var formatterComponents []string

	if baseFormatter == "" {
		_, err := exec.LookPath("goimports")
		if err != nil {
			formatterComponents = []string{"gofmt"}
		} else {
			formatterComponents = []string{"goimports"}
		}
	} else {
		formatterComponents = strings.Split(baseFormatter, " ")
	}

	s := &Shortener{
		maxLen:          maxLen,
		tabLen:          tabLen,
		keepAnnotations: keepAnnotations,
		shortenComments: shortenComments,
		ignoreGenerated: ignoreGenerated,
		baseFormatter:   formatterComponents[0],
	}

	if len(formatterComponents) > 1 {
		s.baseFormatterArgs = formatterComponents[1:]
	} else {
		s.baseFormatterArgs = []string{}
	}

	return s
}

func (s *Shortener) Shorten(contents []byte) ([]byte, error) {
	if s.ignoreGenerated && s.isGenerated(contents) {
		return contents, nil
	}

	round := 0
	var err error

	contents, err = s.formatSrc(contents)
	if err != nil {
		return nil, fmt.Errorf("Error formatting source: %+v", err)
	}

	for {
		log.Debugf("Starting round %d", round)

		var linesToShorten int
		contents, linesToShorten = s.annotateLongLines(contents)
		if linesToShorten == 0 {
			log.Debugf("No more lines to shorten, breaking")
			break
		}

		result, err := decorator.Parse(contents)
		if err != nil {
			return nil, err
		}
		if round == 0 {
			log.Debug("Parse tree:\n", spew.Sdump(result))
		}

		for _, decl := range result.Decls {
			s.formatNode(decl)
		}

		output := bytes.NewBuffer([]byte{})
		err = decorator.Fprint(output, result)
		if err != nil {
			return nil, fmt.Errorf("Error parsing source: %+v", err)
		}
		contents = output.Bytes()

		round++

		if round > maxRounds {
			log.Debugf("Hit max rounds, stopping")
			break
		}
	}

	if !s.keepAnnotations {
		contents = s.removeAnnotations(contents)
	}
	if s.shortenComments {
		contents = s.shortenCommentsFunc(contents)
	}

	contents, err = s.formatSrc(contents)
	if err != nil {
		return nil, fmt.Errorf("Error formatting source: %+v", err)
	}

	return contents, nil
}

func (s *Shortener) formatSrc(contents []byte) ([]byte, error) {
	if s.baseFormatter == "gofmt" {
		return format.Source(contents)
	}

	cmd := exec.Command(s.baseFormatter, s.baseFormatterArgs...)
	stdinPipe, err := cmd.StdinPipe()
	if err != nil {
		return nil, err
	}

	outBuffer := &bytes.Buffer{}
	cmd.Stdout = outBuffer

	if err = cmd.Start(); err != nil {
		return nil, err
	}

	_, err = stdinPipe.Write(contents)
	if err != nil {
		return nil, err
	}
	stdinPipe.Close()

	err = cmd.Wait()
	if err != nil {
		return nil, err
	}

	return outBuffer.Bytes(), nil
}

func (s *Shortener) annotateLongLines(contents []byte) ([]byte, int) {
	annotatedLines := []string{}
	lines := strings.Split(string(contents), "\n")

	linesToShorten := 0
	prevLen := -1

	for _, line := range lines {
		length := s.lineLen(line)

		if prevLen > -1 {
			if length <= s.maxLen {
				// Shortening successful, remove previous annotation
				annotatedLines = annotatedLines[:len(annotatedLines)-1]
			} else if length < prevLen {
				// Replace annotation with new length
				annotatedLines[len(annotatedLines)-1] = fmt.Sprintf(
					"// __golines:shorten:%d",
					length,
				)
				linesToShorten += 1
			}
		} else if !s.isComment(line) && length > s.maxLen {
			annotatedLines = append(
				annotatedLines,
				fmt.Sprintf(
					"// __golines:shorten:%d",
					length,
				),
			)
			linesToShorten += 1
		}

		annotatedLines = append(annotatedLines, line)
		prevLen = s.parseAnnotation(line)
	}

	return []byte(strings.Join(annotatedLines, "\n")), linesToShorten
}

func (s *Shortener) removeAnnotations(contents []byte) []byte {
	cleanedLines := []string{}
	lines := strings.Split(string(contents), "\n")

	for _, line := range lines {
		if !s.isAnnotation(line) {
			cleanedLines = append(cleanedLines, line)
		}
	}

	return []byte(strings.Join(cleanedLines, "\n"))
}

func (s *Shortener) shortenCommentsFunc(contents []byte) []byte {
	cleanedLines := []string{}
	lines := strings.Split(string(contents), "\n")

	for _, line := range lines {
		if s.isComment(line) && !s.isAnnotation(line) &&
			!s.isGoDirective(line) &&
			s.lineLen(line) > s.maxLen {
			start := strings.Index(line, "//")
			prefix := line[0:(start + 2)]
			maxCommentLen := s.maxLen - s.lineLen(prefix) + 1

			trimmedLine := strings.Trim(line[(start+2):], " ")
			words := strings.Split(trimmedLine, " ")

			currLineWords := []string{}
			currLineLen := 0

			for _, word := range words {
				if currLineLen+1+len(word) > maxCommentLen {
					cleanedLines = append(
						cleanedLines,
						fmt.Sprintf(
							"%s %s",
							prefix,
							strings.Join(currLineWords, " "),
						),
					)

					currLineWords = []string{}
					currLineLen = 0
				}

				currLineWords = append(currLineWords, word)
				if currLineLen == 0 {
					currLineLen = len(word)
				} else {
					currLineLen += 1 + len(word)
				}
			}

			if currLineLen > 0 {
				cleanedLines = append(
					cleanedLines,
					fmt.Sprintf(
						"%s %s",
						prefix,
						strings.Join(currLineWords, " "),
					),
				)
			}
		} else {
			cleanedLines = append(cleanedLines, line)
		}
	}

	return []byte(strings.Join(cleanedLines, "\n"))
}

func (s *Shortener) lineLen(line string) int {
	length := 0

	for _, char := range line {
		if char == '\t' {
			length += s.tabLen
		} else {
			length += 1
		}
	}

	return length
}

func (s *Shortener) isAnnotation(line string) bool {
	return strings.HasPrefix(
		strings.Trim(line, " \t"),
		"// __golines:shorten:",
	)
}

func (s *Shortener) parseAnnotation(line string) int {
	if s.isAnnotation(line) {
		components := strings.SplitN(line, ":", 3)
		val, err := strconv.Atoi(components[2])
		if err != nil {
			return -1
		}
		return val
	}
	return -1
}

func (s *Shortener) isComment(line string) bool {
	return strings.HasPrefix(strings.Trim(line, " \t"), "//")
}

func (s *Shortener) isGoDirective(line string) bool {
	return goDirectiveLine.MatchString(line)
}

func (s *Shortener) formatNode(node dst.Node) {
	switch n := node.(type) {
	case dst.Decl:
		log.Debugf("Processing declaration: %+v", n)
		s.formatDecl(n)
	case dst.Expr:
		log.Debugf("Processing expression: %+v", n)
		s.formatExpr(n, false)
	case dst.Stmt:
		log.Debugf("Processing statement: %+v", n)
		s.formatStmt(n)
	case dst.Spec:
		log.Debugf("Processing spec: %+v", n)
		s.formatSpec(n)
	default:
		log.Debugf(
			"Got a node type that can't be shortened: %+v",
			reflect.TypeOf(n),
		)
	}
}

func (s *Shortener) formatDecl(decl dst.Decl) {
	switch d := decl.(type) {
	case *dst.FuncDecl:
		if s.hasAnnotationRecursive(decl) {
			if d.Type != nil && d.Type.Params != nil {
				s.formatFieldList(d.Type.Params)
			}
		}
		s.formatStmt(d.Body)
	case *dst.GenDecl:
		for _, spec := range d.Specs {
			s.formatNode(spec)
		}
	default:
		log.Debugf(
			"Got a declaration type that can't be shortened: %+v",
			reflect.TypeOf(d),
		)
	}
}

func (s *Shortener) formatFieldList(fieldList *dst.FieldList) {
	for f, field := range fieldList.List {
		if f == 0 {
			field.Decorations().Before = dst.NewLine
		} else {
			field.Decorations().Before = dst.None
		}

		field.Decorations().After = dst.NewLine
	}
}

func (s *Shortener) formatStmt(stmt dst.Stmt) {
	// Explicitly check for nil statements
	stmtType := reflect.TypeOf(stmt)
	if reflect.ValueOf(stmt) == reflect.Zero(stmtType) {
		return
	}

	shouldShorten := s.hasAnnotation(stmt)

	switch st := stmt.(type) {
	case *dst.AssignStmt:
		for _, expr := range st.Rhs {
			s.formatExpr(expr, shouldShorten)
		}
	case *dst.BlockStmt:
		for _, stmt := range st.List {
			s.formatStmt(stmt)
		}
	case *dst.CaseClause:
		if shouldShorten {
			for _, arg := range st.List {
				arg.Decorations().After = dst.NewLine
				s.formatExpr(arg, false)
			}
		}

		for _, stmt := range st.Body {
			s.formatStmt(stmt)
		}
	case *dst.CommClause:
		for _, stmt := range st.Body {
			s.formatStmt(stmt)
		}
	case *dst.DeferStmt:
		s.formatExpr(st.Call, shouldShorten)
	case *dst.ExprStmt:
		s.formatExpr(st.X, shouldShorten)
	case *dst.ForStmt:
		s.formatStmt(st.Body)
	case *dst.GoStmt:
		s.formatExpr(st.Call, shouldShorten)
	case *dst.IfStmt:
		s.formatExpr(st.Cond, shouldShorten)
		s.formatStmt(st.Body)
	case *dst.RangeStmt:
		s.formatStmt(st.Body)
	case *dst.ReturnStmt:
		for _, expr := range st.Results {
			s.formatExpr(expr, shouldShorten)
		}
	case *dst.SelectStmt:
		s.formatStmt(st.Body)
	case *dst.SwitchStmt:
		s.formatStmt(st.Body)
	default:
		if shouldShorten {
			log.Debugf(
				"Got a statement type that can't be shortened: %+v",
				reflect.TypeOf(st),
			)
		}
	}
}

func (s *Shortener) formatExpr(expr dst.Expr, force bool) {
	shouldShorten := force || s.hasAnnotation(expr)

	switch e := expr.(type) {
	case *dst.BinaryExpr:
		if (e.Op == token.LAND || e.Op == token.LOR) && shouldShorten {
			e.Y.Decorations().Before = dst.NewLine
		} else {
			s.formatExpr(e.X, shouldShorten)
			s.formatExpr(e.Y, shouldShorten)
		}
	case *dst.CallExpr:
		for a, arg := range e.Args {
			if shouldShorten || s.hasAnnotationRecursive(e) {
				if a == 0 {
					arg.Decorations().Before = dst.NewLine
				} else {
					arg.Decorations().After = dst.None
				}
				arg.Decorations().After = dst.NewLine
			}
			s.formatExpr(arg, false)
		}
		s.formatExpr(e.Fun, shouldShorten)
	case *dst.CompositeLit:
		if shouldShorten {
			for i, element := range e.Elts {
				if i == 0 {
					element.Decorations().Before = dst.NewLine
				}
				element.Decorations().After = dst.NewLine
			}
		}

		for _, element := range e.Elts {
			s.formatExpr(element, false)
		}
	case *dst.FuncLit:
		s.formatStmt(e.Body)
	case *dst.FuncType:
		if shouldShorten {
			s.formatFieldList(e.Params)
		}
	case *dst.InterfaceType:
		for _, method := range e.Methods.List {
			if s.hasAnnotation(method) {
				s.formatExpr(method.Type, true)
			}
		}
	case *dst.KeyValueExpr:
		s.formatExpr(e.Value, shouldShorten)
	case *dst.SelectorExpr:
		s.formatExpr(e.X, shouldShorten)
	case *dst.UnaryExpr:
		s.formatExpr(e.X, shouldShorten)
	default:
		if shouldShorten {
			log.Debugf(
				"Got an expression type that can't be shortened: %+v",
				reflect.TypeOf(e),
			)
		}
	}
}

func (s *Shortener) formatSpec(spec dst.Spec) {
	shouldShorten := s.hasAnnotation(spec)

	switch sp := spec.(type) {
	case *dst.ValueSpec:
		for _, expr := range sp.Values {
			s.formatExpr(expr, shouldShorten)
		}
	case *dst.TypeSpec:
		s.formatExpr(sp.Type, false)
	default:
		if shouldShorten {
			log.Debugf(
				"Got a spec type that can't be shortened: %+v",
				reflect.TypeOf(sp),
			)
		}
	}
}

func (s *Shortener) hasAnnotation(node dst.Node) bool {
	startDecorations := node.Decorations().Start.All()
	return len(startDecorations) > 0 &&
		s.isAnnotation(startDecorations[len(startDecorations)-1])
}

func (s *Shortener) hasAnnotationRecursive(node dst.Node) bool {
	if s.hasAnnotation(node) {
		return true
	}

	switch n := node.(type) {
	case *dst.FuncDecl:
		if n.Type != nil && n.Type.Params != nil {
			for _, item := range n.Type.Params.List {
				if s.hasAnnotationRecursive(item) {
					return true
				}
			}
		}
	case *dst.Field:
		return s.hasAnnotation(n)
	case *dst.CallExpr:
		for _, arg := range n.Args {
			if s.hasAnnotation(arg) {
				return true
			}
		}
	}

	return false
}

func (s *Shortener) isGenerated(contents []byte) bool {
	var head string

	if len(contents) > 80 {
		head = strings.ToLower(string(contents[0:80]))
	} else {
		head = strings.ToLower(string(contents))
	}

	for _, term := range generatedTerms {
		if strings.Index(head, term) >= 0 {
			return true
		}
	}

	return false
}
